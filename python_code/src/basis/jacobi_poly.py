import sympy as sp
from sympy import Matrix as spmtx
from sympy import *
from sympy import symbols as syms
from sympy.utilities.lambdify import lambdify, lambdastr
import math
from collections import deque
import copy
from copy import deepcopy
import random
import numpy as np
from scipy import integrate as sci_int



class jacobi_poly:
    '''
    The jacobi polynomial basis class
    data_field:
        alpha, beta: To specify the polynomial
        var_list: A list of symbols for different variables
        num_var: The number of variables
        degree: The total degree of the polynomial
        base: A list of terms that the basis consists
        base_vec: A sympy matrix (vector) of each element in the basis.
        coeff: A list of coeffs related to each basis
        norm: A dictionary of norm of an element in basis
    '''
    def _rodrigues_formula(self, a, b, n, x):
        f = (1-x) ** a * (1+x) ** b  * (1-x**2) ** n
        for i in range(n):
            f = sp.diff(f, x)
        t = (-1)**n / (2 ** n * math.factorial(n)) * (1-x) ** (-a) * (1-x)** (-b) * f
        t = sp.expand(t)
        return t
    
    def _gen_terms_uni(self):
        '''
        Description:
            Generate the terms that consists of univiarate jacobi polynomial
        Reference:
            We shall create the terms using Rodrigues' formula
        Output:
            A list of terms
        '''
        if self.degree == 0:
            return [1]
        a = self.alpha
        b = self.beta
        x = self.var_list[0]
        terms = [1, (a + 1) + (a + b + 2) * (x-1) / 2]
        for n in range(2, self.degree + 1):
            terms.append(self._rodrigues_formula(a, b, n, x))
        return terms
    
    def _gen_terms_biv(self):
        '''
        Description:
            Generate all the terms in a bases of bivaraite polynomials using
            bivariate chebyshev polynomial of the first kind
        Reference:
             The construction of multivariate chebyshev is based on what Gergely MÃ¡di-Nagy proposed in his
            "Polynomial bases on the numerical solution of the multivariate discrete moment problem"
        Input:
            total_degree --- the maximun degree of the polynomial
        '''
        if self.degree == 0:
            return [1]
        total_degree = self.degree
        var_list = []
        for i in range(len(self.var_list)):
            var_list.append(self.var_list.popleft())
        self.var_list = deque()
        self.var_list.append(var_list[0])
        terms_x_0 = self._gen_terms_uni()
        self.var_list.popleft()
        
        self.var_list.append(var_list[1])
        terms_x_1 = self._gen_terms_uni()
        self.var_list.popleft()
        
        for var in var_list:
            self.var_list.append(var)
        terms = []
        for order_1 in range(len(terms_x_1)):
            for order_0 in range(len(terms_x_0) - order_1):
                terms.append(terms_x_0[order_0] * terms_x_1[order_1])
                # terms.append(sp.expand(x_0 * x_1))
        return terms
    
    def __init__(self, deg, num_var, alpha, beta, coeff=None):
        '''
        Description:
            Initalize a basis of the polynomail space by the jacobi polynomial
        Input:
            deg --- The max degree of the polynomail space
            num_var --- number of variables in the polynomial space
        '''
        self.alpha = alpha
        self.beta = beta
        
        if num_var > 2:
            raise ValueError("Only support 2 variable max")
        
        self.degree = deg
        self.num_var = num_var
        
        self.var_list = deque()
        for i in range(num_var):
            self.var_list.append(syms('x_' + str(i)))
        
        if num_var == 1:
            terms = self._gen_terms_uni()
        else:
            terms = self._gen_terms_biv()
       
        self.base = terms
        self.base_vec = spmtx(terms) # arrange the terms in a vector format
        
        if coeff == None:
            pass
        self.coeff = coeff
        
        self.norm = dict()
        i = 0
         
        for b in self.base:
            self.norm[b] = self._base_norm(b, num_var)
    
    def _base_norm(self, basis, num_var):
        if num_var == 1:
            x = self.var_list[0]
            a = self.alpha
            b = self.beta
            weight = (1-x)**a * (1+x)**b
            f = lambdify(self.var_list[0], (basis * basis) * weight)
            r = sci_int.quad(f, -1, 1, epsabs=1e-5, epsrel=1e-5, limit=20)[0]
            return round(r, 5)
        
    def c_extract_map(self, poly, basis, num_var):
        '''
        Description:
            Using orthogonality to extract the coefficient of a vector in the basis in the input polynomial.
            The basis should be generated by the constructor of this class.
        Reference:
            "Polynomial bases on the numerical solution of the multivariate discrete moment problem"
        Input:
            poly --- A given polynomial
            basis --- An element in the first kind chebyshve basis 
            num_var --- Univariate vs Bivariate
        '''
        if num_var > 2:
            raise ValueError("Only support 2 variable max")
        if num_var == 1:
            x = self.var_list[0]
            a = self.alpha
            b = self.beta
            weight = (1-x)**a * (1+x)**b
            f = lambdify(self.var_list[0], (poly * basis) * weight)
            r = sci_int.quad(f, -1, 1, epsabs=1e-5, epsrel=1e-5, limit=20)[0]
            if abs(r) < 1e-5:
                return 0
            else:
                return round(r / self.norm[basis], 5)
        if num_var == 2:
            x = self.var_list[0]
            y = self.var_list[1]
            a = self.alpha
            b = self.beta
            weight = (1-x)**a * (1+x)**b * (1-y)**a * (1+y) **b
            f = lambdify(self.var_list, poly * basis * weight)
            r = sci_int.nquad(f, [[-1,1],[-1, 1]], opts=[{'epsabs':1e-4, 'epsrel':1e-4, 'limit': 15}, 
                                                         {'epsabs':1e-4, 'epsrel':1e-4, 'limit': 15}])[0]
            if abs(r) < 1e-4:
                return 0
            else:
                return round(r/self.norm[basis], 5)
    

if __name__ == '__main__':
    r = jacobi_poly(deg=(4 // 2), num_var = 1, alpha = 1, beta = 0)